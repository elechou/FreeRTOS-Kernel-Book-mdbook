## 12.5 Viewing Run-time and Task State Information

### 12.5.1 Task Run-Time Statistics

Task run-time statistics provide information on the amount of processing
time each task has received. A task's *run time* is the total time the
task has been in the Running state since the application booted.

Run-time statistics are intended to be used as a profiling and debugging
aid during the development phase of a project. The information they
provide is only valid until the counter used as the run-time statistics
clock overflows. Collecting run-time statistics will increase the task
context switch time.

To obtain binary run-time statistics information, call the
`uxTaskGetSystemState()` API function. To obtain run-time statistics
information as a human readable ASCII table, call the
`vTaskGetRunTimeStatistics()` helper function.


### 12.5.2 The Run-Time Statistics Clock

Run-time statistics need to measure fractions of a tick period.
Therefore, the RTOS tick count is not used as the run-time statistics
clock, and the clock is instead provided by the application code. It is
recommended to make the frequency of the run-time statistics clock
between 10 and 100 times faster than the frequency of the tick
interrupt. The faster the run-time statistics clock, the more accurate
the statistics will be, but also the sooner the time value will
overflow.

Ideally, the time value will be generated by a free-running 32-bit
peripheral timer/counter, the value of which can be read with no other
processing overhead. If the available peripherals and clock speeds do
not make that technique possible, then alternative, but less efficient,
techniques include:

- Configure a peripheral to generate a periodic interrupt at the
  desired run-time statistics clock frequency, and then use a count
  of the number of interrupts generated as the run-time statistics clock.

  This method is very inefficient if the periodic interrupt is only
  used for the purpose of providing a run-time statistics clock.
  However, if the application already uses a periodic interrupt with a
  suitable frequency, then it is simple and efficient to add a count
  of the number of interrupts generated into the existing interrupt
  service routine.

- Generate a 32-bit value by using the current value of a free running
  16-bit peripheral timer as the 32-bit value's least significant
  16-bits, and the number of times the timer has overflowed as the
  32-bit value's most significant 16-bits.

It is possible, with appropriate and somewhat complex manipulation, to
generate a run-time statistics clock by combining the RTOS tick count
with the current value of an ARM Cortex-M SysTick timer. Some of the
demo projects in the FreeRTOS download demonstrate how this is achieved.


### 12.5.3 Configuring an Application to Collect Run-Time Statistics

Below are details on the macros necessary to collect task run-time
statistics. Originally, the macros were intended to be included in
the RTOS port layer, which is why the macros are prefixed 'port', but it
has proven more practical to define them in `FreeRTOSConfig.h`.

**Macros used in the collection of run-time statistics**

- `configGENERATE_RUN_TIME_STATS`

  This macro must be set to 1 in FreeRTOSConfig.h. When this macro is
  set to 1 the scheduler will call the other macros detailed in this section
  at the appropriate times.

- `portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()`

  This macro must be provided to initialize whichever peripheral is
  used to provide the run-time statistics clock.

- `portGET_RUN_TIME_COUNTER_VALUE()`, or `portALT_GET_RUN_TIME_COUNTER_VALUE(Time)`

  One of these two macros must be provided to return the current
  run-time statistics clock value. This is the total time the application
  has been running, in run-time statistics clock units, since the
  application first booted.

  If the first macro is used, it must be defined to evaluate to the
  current clock value. If the second macro is used, it must be defined to
  set its 'Time' parameter to the current clock value.


### 12.5.4 The uxTaskGetSystemState() API Function

`uxTaskGetSystemState()` provides a snapshot of status information for
each task under the control of the FreeRTOS scheduler. The information
is provided as an array of `TaskStatus_t` structures, with one index in
the array for each task. `TaskStatus_t` is described by Listing 12.5 and
below.


<a name="list12.4" title="Listing 12.4 The uxTaskGetSystemState() API function prototype"></a>

```c
UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray,
                                  const UBaseType_t uxArraySize,
                                  configRUN_TIME_COUNTER_TYPE * const pulTotalRunTime );
```
***Listing 12.4*** *The uxTaskGetSystemState() API function prototype*

> Note: `configRUN_TIME_COUNTER_TYPE` defaults to `uint32_t` for backward compatibility, but can be 
> overridden in FreeRTOSConfig.h if `uint32_t` is too restrictive.


**uxTaskGetSystemState() parameters and return value**

- `pxTaskStatusArray`

  A pointer to an array of `TaskStatus_t` structures.

  The array must contain at least one `TaskStatus_t` structure for each
  task. The number of tasks can be determined using the
  `uxTaskGetNumberOfTasks()` API function.

  The `TaskStatus_t` structure is shown in Listing 12.5, and the
  TaskStatus\_t structure members are described in the next list.

- `uxArraySize`

  The size of the array pointed to by the `pxTaskStatusArray` parameter.
  The size is specified as the number of indexes in the array (the number
  of `TaskStatus_t` structures contained in the array), not by the number of
  bytes in the array.

- `pulTotalRunTime`

  If `configGENERATE_RUN_TIME_STATS` is set to 1 in `FreeRTOSConfig.h`,
  then `*pulTotalRunTime` is set by `uxTaskGetSystemState()` to the total run
  time (as defined by the run-time statistics clock provided by the
  application) since the target booted.

  `pulTotalRunTime` is optional, and can be set to NULL if the total run
  time is not required.

- Return value

  The number of `TaskStatus_t` structures that were populated by
  `uxTaskGetSystemState()` is returned.

  The returned value should equal the number returned by the
  `uxTaskGetNumberOfTasks()` API function, but will be zero if the value
  passed in the `uxArraySize` parameter was too small.


<a name="list12.5" title="Listing 12.5 The TaskStatus\_t structure"></a>

```c
typedef struct xTASK_STATUS
{
    TaskHandle_t xHandle;
    const char *pcTaskName;
    UBaseType_t xTaskNumber;
    eTaskState eCurrentState;
    UBaseType_t uxCurrentPriority;
    UBaseType_t uxBasePriority;
    configRUN_TIME_COUNTER_TYPE ulRunTimeCounter;
    StackType_t * pxStackBase;
    #if ( ( portSTACK_GROWTH > 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )
        StackType_t * pxTopOfStack;
        StackType_t * pxEndOfStack;
    #endif
    uint16_t usStackHighWaterMark;
    #if ( ( configUSE_CORE_AFFINITY == 1 ) && ( configNUMBER_OF_CORES > 1 ) )
        UBaseType_t uxCoreAffinityMask;
    #endif
} TaskStatus_t;
```
***Listing 12.5*** *The TaskStatus\_t structure*

**TaskStatus_t structure members**

- `xHandle`

  The handle of the task to which the information in the structure relates.

- `pcTaskName`

  The human readable text name of the task.

- `xTaskNumber`

  Each task has a unique `xTaskNumber` value.

  If an application creates and deletes tasks at run time then it is
  possible that a task will have the same handle as a task that was
  previously deleted. `xTaskNumber` is provided to allow application code,
  and kernel aware debuggers, to distinguish between a task that is still
  valid, and a deleted task that had the same handle as the valid
  task.

- `eCurrentState`

  An enumerated type that holds the state of the task.
  `eCurrentState` can be one of the following values: 
  
  - `eRunning`
  - `eReady`
  - `eBlocked`
  - `eSuspended`
  - `eDeleted`

  A task will only be reported as being in the `eDeleted` state for the
  short period between the time the task was deleted by a call to
  `vTaskDelete()`, and the time the Idle task frees the memory that was
  allocated to the deleted task's internal data structures and stack.
  After that time, the task will no longer exist in any way, and it is
  invalid to attempt to use its handle.

- `uxCurrentPriority`

  The priority at which the task was running at the time
  `uxTaskGetSystemState()` was called. `uxCurrentPriority` will only be higher
  than the priority assigned to the task by the application writer if the
  task has temporarily been assigned a higher priority in accordance with
  the priority inheritance mechanism described in section
  [8.3 Mutexes (and Binary Semaphores)](ch08.md#83-mutexes-and-binary-semaphores).

- `uxBasePriority`

  The priority assigned to the task by the application writer.
  `uxBasePriority` is only valid if `configUSE_MUTEXES` is set to 1 in
  FreeRTOSConfig.h.

- `ulRunTimeCounter`

  The total run time used by the task since the task was created. The
  total run time is provided as an absolute time that uses the clock
  provided by the application writer for the collection of run-time
  statistics. `ulRunTimeCounter` is only valid if
  `configGENERATE_RUN_TIME_STATS` is set to 1 in FreeRTOSConfig.h.
  
- `pxStackBase`

   Points to the base address of the stack region allotted to this task.

- `pxTopOfStack`

   Points to the current top address of the stack region allotted to this task.
   The field `pxTopOfStack` is only valid if either the stack grows upwards (i.e.
   `portSTACK_GROWTH` is greater than zero) or `configRECORD_STACK_HIGH_ADDRESS`
   is set to 1 in FreeRTOSConfig.h.

- `pxEndOfStack`

   Points to the end address of the of the stack region allotted to this task.
   The field `pxEndOfStack` is only valid if either the stack grows upwards (i.e.
   `portSTACK_GROWTH` is greater than zero) or `configRECORD_STACK_HIGH_ADDRESS`
   is set to 1 in FreeRTOSConfig.h.

- `usStackHighWaterMark`

  The task's stack high water mark. This is the minimum amount of
  stack space that has remained for the task since the task was created.
  It is an indication of how close the task has come to overflowing its
  stack; the closer this value is to zero, the closer the task has come to
  overflowing its stack. `usStackHighWaterMark` is specified in bytes.
  
- `uxCoreAffinityMask`

   A bitwise value that indicates the cores on which the task can run. 
   Cores are numbered from 0 to `configNUMBER_OF_CORES` - 1. For example, a
   task that can run on core 0 and core 1 will have its `uxCoreAffinityMask`
   set to 0x03. The field `uxCoreAffinityMask` is only available if both
   `configUSE_CORE_AFFINITY` is set to 1 and `configNUMBER_OF_CORES`
   is set to greater than 1 in FreeRTOSConfig.h.


### 12.5.5 The vTaskListTasks() Helper Function

`vTaskListTasks()` provides similar task status information to that provided by
`uxTaskGetSystemState()`, but it presents the information as a human
readable ASCII table, rather than an array of binary values.

`vTaskListTasks()` is a very processor intensive function, and leaves the
scheduler suspended for an extended period. Therefore, it is recommended
to use the function for debug purposes only, and not in a production
real-time system.

`vTaskListTasks()` is available if `configUSE_TRACE_FACILITY` is set to 1 and
`configUSE_STATS_FORMATTING_FUNCTIONS` is set to greater than 0 in
FreeRTOSConfig.h.


<a name="list12.6" title="Listing 12.6 The vTaskListTasks() API function prototype"></a>

```c
void vTaskListTasks( char * pcWriteBuffer, size_t uxBufferLength );
```
***Listing 12.6*** *The vTaskListTasks() API function prototype*

**vTaskListTasks() parameters**

- `pcWriteBuffer`

  A pointer to a character buffer into which the formatted and human readable table is written. 
  This buffer is assumed to be large enough to contain the generated report.  
  Approximately 40 bytes per task should be sufficient.

- `uxBufferLength`

  Length of the `pcWriteBuffer`.

An example of the output generated by `vTaskListTasks()` is shown in Figure 12.7.
In the output:

- Each row provides information on a single task.

- The first column is the task's name.

- The second column is the task's state, where 'X' means Running, 'R' means Ready, 'B'
  means Blocked, 'S' means Suspended, and 'D' means the task has been
  deleted. A task will only be reported as being in the deleted state
  for the short period between the time the task was deleted by a call
  to `vTaskDelete()`, and the time the Idle task frees the memory that
  was allocated to the deleted task's internal data structures and
  stack. After that time, the task will no longer exist in any way,
  and it is invalid to attempt to use its handle.

- The third column is the task's priority.

- The fourth column is the task's stack high water mark. See the
  description of `usStackHighWaterMark`.

- The fifth column is the unique number allocated to the task. See the
  description of `xTaskNumber`.


<a name="fig12.7" title="Figure 12.7 Example output generated by vTaskListTasks()"></a>

<div align="center">
<img src="../media/image88.png" alt="Figure 12.7 *Example output generated by vTaskListTasks()*"/>

***Figure 12.7*** **Example output generated by vTaskListTasks()**
</div>

> Note:   
> The older version of `vTaskListTasks` is `vTaskList`. `vTaskList` assumes that the 
> `pcWriteBuffer` is of length `configSTATS_BUFFER_MAX_LENGTH`. This function is there only for 
> backward compatibility. New applications are recommended to use `vTaskListTasks` and 
> supply the length of the `pcWriteBuffer` explicitly.


<a name="list12.7" title="Listing 12.7 The vTaskList() API function prototype"></a>

```c
void vTaskList( signed char *pcWriteBuffer );
```
***Listing 12.7*** *The vTaskList() API function prototype*

  **vTaskList() parameters**

  - `pcWriteBuffer`
    
    A pointer to a character buffer into which the formatted and human readable table is written. 
    The buffer must be large enough to hold the entire table, as no boundary checking is performed.


### 12.5.6 The vTaskGetRunTimeStatistics() Helper Function

`vTaskGetRunTimeStatistics()` formats collected run-time statistics into a
human readable ASCII table.

`vTaskGetRunTimeStatistics()` is a very processor intensive function and leaves
the scheduler suspended for an extended period. Therefore, it is
recommended to use the function for debug purposes only, and not in a
production real-time system.

`vTaskGetRunTimeStatistics()` is available when `configGENERATE_RUN_TIME_STATS` is set to
1, `configUSE_STATS_FORMATTING_FUNCTIONS` is set greater than 0, and 
`configUSE_TRACE_FACILITY` is set to 1 in FreeRTOSConfig.h.


<a name="list12.8" title="Listing 12.8 The vTaskGetRunTimeStatistics() API function prototype"></a>

```c
void vTaskGetRunTimeStatistics( char * pcWriteBuffer, size_t uxBufferLength );
```
***Listing 12.8*** *The vTaskGetRunTimeStatistics() API function prototype*

**vTaskGetRunTimeStatistics() parameters**

- `pcWriteBuffer`

  A pointer to a character buffer into which the formatted and human readable table is written.
  This buffer is assumed to be large enough to contain the generated report.  
  Approximately 40 bytes per task should be sufficient.

- `uxBufferLength` 

  Length of the `pcWriteBuffer`.

An example of the output generated by `vTaskGetRunTimeStatistics()` is shown in
Figure 12.8. In the output:

- Each row provides information on a single task.

- The first column is the task name.

- The second column is the amount of time the task has spent in the
  Running state as an absolute value. See the description of
  `ulRunTimeCounter`.

- The third column is the amount of time the task has spent in the
  Running state as a percentage of the total time since the target was
  booted. The total of the displayed percentage times will normally be
  less than the expected 100% because statistics are collected and
  calculated using integer calculations that round down to the nearest
  integer value.


<a name="fig12.8" title="Figure 12.8 Example output generated by vTaskGetRunTimeStatistics()"></a>

<div align="center">
<img src="../media/image89.png" alt="Figure 12.8 *Example output generated by vTaskGetRunTimeStatistics()*"/>

***Figure 12.8*** **Example output generated by vTaskGetRunTimeStatistics()**
</div>

> Note:   
> The older version of `vTaskGetRunTimeStatistics` is `vTaskGetRunTimeStats`. 
> `vTaskGetRunTimeStats` assumes that the pcWriteBuffer is of length
> `configSTATS_BUFFER_MAX_LENGTH`. This function is there only for backward compatiblity. 
> New applications are recommended to use `vTaskGetRunTimeStatistics` and supply the length 
> of the pcWriteBuffer explicitly.


 <a name="list12.9" title="Listing 12.9 The vTaskGetRunTimeStats() API function prototype"></a>

 ```c
 void vTaskGetRunTimeStats( signed char *pcWriteBuffer );
 ```
 ***Listing 12.9*** *The vTaskGetRunTimeStats() API function prototype*
 
  **vTaskGetRunTimeStats() parameters**

  - `pcWriteBuffer`

    A pointer to a character buffer into which the formatted and human readable table is written. The 
    buffer must be large enough to hold the entire table, as no boundary checking is performed.


### 12.5.7 Generating and Displaying Run-Time Statistics, a Worked Example

This example uses a hypothetical 16-bit timer to generate a 32-bit
run-time statistics clock. The counter is configured to generate an
interrupt each time the 16-bit value reaches its maximum
valueâ€”effectively creating an overflow interrupt. The interrupt service
routine counts the number of overflow occurrences.

The 32-bit value is created by using the count of overflow occurrences
as the two most significant bytes of the 32-bit value, and the current
16-bit counter value as the two least significant bytes of the 32-bit
value. Pseudo code for the interrupt service routine is shown in Listing
12.10.


<a name="list12.10" title="Listing 12.10 16-bit timer overflow interrupt handler used to count timer overflows"></a>

```c
void TimerOverflowInterruptHandler( void )
{
    /* Just count the number of interrupts. */
    ulOverflowCount++;

    /* Clear the interrupt. */
    ClearTimerInterrupt();
}
```
***Listing 12.10*** *16-bit timer overflow interrupt handler used to count timer overflows*

Listing 12.11 shows the lines added to FreeRTOSConfig.h to enable the
collection of run-time statistics.


<a name="list12.11" title="Listing 12.11 Macros added to FreeRTOSConfig.h to enable the collection of run-time statistics"></a>

```c
/* Set configGENERATE_RUN_TIME_STATS to 1 to enable collection of run-time 
   statistics. When this is done, both portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()
   and portGET_RUN_TIME_COUNTER_VALUE() or 
   portALT_GET_RUN_TIME_COUNTER_VALUE(x) must also be defined. */
#define configGENERATE_RUN_TIME_STATS 1

/* portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() is defined to call the function 
   that sets up the hypothetical 16-bit timer (the function's implementation 
   is not shown). */
void vSetupTimerForRunTimeStats( void );
#define portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()  vSetupTimerForRunTimeStats()

/* portALT_GET_RUN_TIME_COUNTER_VALUE() is defined to set its parameter to the
   current run-time counter/time value. The returned time value is 32-bits 
   long, and is formed by shifting the count of 16-bit timer overflows into 
   the top two bytes of a 32-bit number, then bitwise ORing the result with 
   the current 16-bit counter value. */
#define portALT_GET_RUN_TIME_COUNTER_VALUE( ulCountValue )                  \
{                                                                           \
    extern volatile unsigned long ulOverflowCount;                          \
                                                                            \
    /* Disconnect the clock from the counter so it does not change          \
       while its value is being used. */                                    \
    PauseTimer();                                                           \
                                                                            \
    /* The number of overflows is shifted into the most significant         \
       two bytes of the returned 32-bit value. */                           \
    ulCountValue = ( ulOverflowCount << 16UL );                             \
                                                                            \
    /* The current counter value is used as the two least significant       \
       bytes of the returned 32-bit value. */                               \
    ulCountValue |= ( unsigned long ) ReadTimerCount();                     \
                                                                            \
    /* Reconnect the clock to the counter. */                               \
    ResumeTimer();                                                          \
}
```
***Listing 12.11*** *Macros added to FreeRTOSConfig.h to enable the collection of run-time statistics*

The task shown in Listing 12.12 prints out the collected run-time statistics every 5 seconds.


<a name="list12.12" title="Listing 12.12 The task that prints out the collected run-time statistics"></a>

```c
#define RUN_TIME_STATS_STRING_BUFFER_LENGTH       512

/* For clarity, calls to fflush() have been omitted from this code listing. */
static void prvStatsTask( void *pvParameters )
{
    TickType_t xLastExecutionTime;

    /* The buffer used to hold the formatted run-time statistics text needs to
       be quite large. It is therefore declared static to ensure it is not
       allocated on the task stack. This makes this function non re-entrant. */
    static signed char cStringBuffer[ RUN_TIME_STATS_STRING_BUFFER_LENGTH ];

    /* The task will run every 5 seconds. */
    const TickType_t xBlockPeriod = pdMS_TO_TICKS( 5000 );

    /* Initialize xLastExecutionTime to the current time. This is the only
       time this variable needs to be written to explicitly. Afterwards it is 
       updated internally within the vTaskDelayUntil() API function. */
    xLastExecutionTime = xTaskGetTickCount();

    /* As per most tasks, this task is implemented in an infinite loop. */
    for( ;; )
    {
        /* Wait until it is time to run this task again. */
        xTaskDelayUntil( &xLastExecutionTime, xBlockPeriod );

        /* Generate a text table from the run-time stats. This must fit into
           the cStringBuffer array. */
        vTaskGetRunTimeStatistics( cStringBuffer, RUN_TIME_STATS_STRING_BUFFER_LENGTH );

        /* Print out column headings for the run-time stats table. */
        printf( "\nTask\t\tAbs\t\t\t%%\n" );
        printf( "-------------------------------------------------------------\n" );

        /* Print out the run-time stats themselves. The table of data contains
           multiple lines, so the vPrintMultipleLines() function is called 
           instead of calling printf() directly. vPrintMultipleLines() simply 
           calls printf() on each line individually, to ensure the line 
           buffering works as expected. */ 
        vPrintMultipleLines( cStringBuffer );
    }
}
```
***Listing 12.12*** *The task that prints out the collected run-time statistics*